# パラダイム近傍とシフト遷移グラフの再設計

## 背景

現行のシフト先選択（最小緩和原理）には以下の問題がある:

1. **同点問題**: 候補条件 `tension(O, P') <= tension(O, P_current)` が同点を許容するため、S1⇄S2 のようなループが発生する
2. **同点除外のジレンマ**: strict `<` にすると、近くのパラダイムが同じ tension を持つ場合に候補から外れ、望まない跳躍が起きうる
3. **発動と選択の分離問題**: threshold(P_current) は「現パラダイムの限界」を表すが、意味的に適切なのは「遷移先パラダイムの発見に必要な証拠量」

根本的な原因は、遷移先の候補を動的な指標のみで決定しており、パラダイム間の構造的な近傍関係が定義されていないこと。

## 新しいシフト遷移モデル

### 二層構造

**実行時ロジック**（ループ防止 + 発動タイミング）:

1. `tension(O, P_target) < tension(O, P_current)` — strict。ループを構造的に排除
2. `resolve(O, P_current, P_target) >= N(P_target)` — 遷移先側の閾値。十分な証拠で発動

**静的構造分析**（跳躍防止）:

- P_current のアノマリー集合への射影で近傍を定義
- 近傍のみが遷移先候補（遠くへの跳躍を排除）

### 遷移先側の閾値 N(P_target)

現行の threshold(P_current) は「P_current がどこまで耐えられるか」を表す。新モデルでは N(P_target) が「P_target という説明に至るために必要な証拠の量」を表す。

意味的には: プレイヤーがどのパラダイムにいるかに関わらず、ある説明を思いつくには一定の観測が必要。これは P_target 固有の性質。

```
resolve(O, P_current, P_target) = |{ d ∈ Anomaly_O(P_current) | P_target が d を正しく予測 }|
```

遷移条件: `resolve(O, P_current, P_target) >= N(P_target)`

### N(P_target) の設計

**上限制約**: N(P_target) は、どの遷移元からでも到達可能でなければならない:

```
N(P_target) <= min over all valid sources P_i of resolve(O*, P_i, P_target)
```

**引っ掛けの順序制約**: 引っ掛けが先に開く:

```
N(S) < N(P_{i+1})
```

上限の範囲内で N を設定する。値はパズル設計上のパラメータ（ペーシング調整）。

### 発動と選択の統合

旧モデルでは「いつシフトするか」(threshold) と「どこにシフトするか」(select_shift_target) が分離していた。

新モデルでは、候補の条件自体が発動を含む:

1. 近傍のうち、tension strict `<` かつ resolve >= N を満たすパラダイムを候補とする
2. 候補が1つ以上あればシフト発動
3. 複数候補がある場合: resolve DESC → attention DESC → pid ASC で選択

## 近傍の定義（射影ベース）

### P_current のアノマリーへの射影

P_current のアノマリー集合を基準に、各候補がどれだけ「残課題」を持つかで順序づける:

```
Remaining(P', P_current) = Anomaly(P_current) ∩ Anomaly(P')
```

P' が P_current のアノマリーをどれだけ共有しているか。少ないほど P' は P_current の問題をより多く解決している。

### Hasse 図による近傍

Remaining 集合の包含関係で Hasse 図を構築。直接の後続（中間パラダイムが存在しない）が近傍。

```
Remaining(P_a) ⊂ Remaining(P_b) ⊂ Anomaly(P_current)
```

のとき、P_a は P_b の近傍ではない（P_b が中間に存在するため）。

### 性質

- **跳躍の排除**: 中間パラダイムが存在する場合は近傍にならない
- **ループ防止は tension strict `<` が担当**: 射影ベースの近傍自体にはループ耐性がなくてよい

## 引っ掛け（トリック）パラダイムの扱い

### 導入アノマリーの許容

旧検討では引っ掛け S に `Anomaly(S) ⊂ Anomaly(P_i)` を要求したが、これは「S が積極的に間違った主張をする」ケースを排除してしまう。

新モデルでは:

- **tension strict `<`** により、S の total アノマリーが P_current より少なければ遷移可能
- S が導入アノマリーを持っていても、ネットで tension が減少していれば許容
- 例: P_current のアノマリー3つを解決し、新たに1つ導入 → tension は2減少 → 遷移可能

### ループの安全性

メインパスでは Anomaly(P_{i+1}) ⊂ Anomaly(P_i) なので、逆方向の resolve は 0。ループ不可能。

引っ掛け S に導入アノマリーがある場合、P_current が S の導入アノマリーを「解決」する可能性があるが、tension strict `<` により P_current に戻ることは:

- P_current の tension > S の tension（遷移条件の逆）
- よって S → P_current は成立しない ✓

### 意味的な根拠

矛盾を多く抱えたパラダイムへ進む動機はない。tension の減少は「より良い説明への移行」を表し、逆方向（矛盾が増える方向）への遷移には合理的な動機がない。

## ウミガメのスープでの具体例

### アノマリー集合（O* ベース）

| パラダイム | |Anomaly| | アノマリー集合 |
|-----------|----------|--------------|
| S1 | 10 | {B-01, Fs-26, Fs-39, Fs-40, Fs-43, Ft-03, Ft-09, Ft-11, Ft-22, Ft-37} |
| S2 | 10 | {B-02, Fs-26, Fs-39, Fs-40, Fs-43, Ft-03, Ft-09, Ft-11, Ft-22, Ft-37} |
| P1 | 9 | {Fs-26, Fs-39, Fs-40, Fs-43, Ft-03, Ft-09, Ft-11, Ft-22, Ft-37} |
| P2 | 4 | {Ft-03, Ft-09, Ft-11, Ft-37} |
| P3 | 2 | {Ft-03, Ft-09} |
| P4 | 1 | {Ft-47} |
| P5 | 0 | {} |

### 近傍（P1 視点の射影）

```
Remaining(P', P1) = Anomaly(P1) ∩ Anomaly(P')

P2: {Ft-03, Ft-09, Ft-11, Ft-37}  (4個、5個解決)
P3: {Ft-03, Ft-09}                 (2個、7個解決)
P5: {}                              (0個、9個解決)
P4: {}                              (0個、9個解決 — Ft-47 は P1 のアノマリーではない)
S1: {Fs-26, Fs-39, Fs-40, Fs-43, Ft-03, Ft-09, Ft-11, Ft-22, Ft-37}  (9個、0個解決)
S2: 同上
```

S1, S2 は P1 のアノマリーを一切解決しない → P1 からの遷移先にならない（resolve = 0）。

Hasse 図（P1 視点）:
```
Anomaly(P1) ⊃ Remaining(P2) ⊃ Remaining(P3) ⊃ Remaining(P5) = {}
```

P2 が P1 の近傍。P3 は中間に P2 があるため近傍でない。

### 現データの課題

- S1/S2 は P1 のアノマリーを解決しないため引っ掛けとして機能しない → データ設計で要修正
- P4 は P3 とは独立の分岐（Ft-47 は P3 のアノマリーではない）→ 分岐構造として正当

## resolve の方向（補足）

resolve のソート方向を ASC（小さい方優先）から DESC（大きい方優先）に修正済み。

resolve が大きい = 候補パラダイムが P_current のアノマリーに取り組んでいる = 適切な遷移先。

## 実装計画

### Phase 1: モデルと閾値の変更

**models.py**:
- `Paradigm.threshold` を `Paradigm.shift_threshold`（N(P_target)）に改名
  - 意味の変更: 元パラダイム側の限界 → 遷移先側の証拠量
  - 型は `Optional[int]` のまま

**threshold.py**:
- `compute_thresholds()` を新ロジックに書き換え:
  1. 全ペアの resolve(O*, P_i, P_j) を計算
  2. `N(P_target) <= min over sources resolve(O*, P_i, P_target)` で上限を導出
  3. 上限値をそのまま N として設定（パズル設計者が後で調整可能）
- `compute_neighborhoods()` を新規追加:
  1. 各 P_current について Remaining(P', P_current) = Anomaly(P_current) ∩ Anomaly(P') を計算
  2. Remaining 集合の Hasse 図を構築
  3. 直接後続のみを近傍として返す
  4. 返り値: `dict[str, set[str]]`（pid → 近傍 pid の集合）

**common.py**:
- `load_data()` で `compute_neighborhoods()` も呼び出し、返り値に追加
  - 既存の返り値タプルに neighborhoods を追加

### Phase 2: エンジンの変更

**engine.py**:
- `select_shift_target()` を書き換え:
  - 候補条件: 近傍 AND tension strict `<` AND resolve >= N(P_target)
  - 選択: resolve DESC → attention DESC → pid ASC
  - 引数に neighborhoods を追加
- `update()` Step 3:
  - `p_current.threshold` → 新条件に差し替え
  - neighborhoods を引数で受け取る（or 内部計算）

**play_simulation.py**:
- neighborhoods を load_data から受け取り、update() に渡す

### Phase 3: 構造検証スクリプトの更新

**shift_path.py**:
- テーマ1（tension 順序）: 変更なし
- テーマ2（シフト先選択と到達性）: 新 select_shift_target で再計算
  - 近傍ベースの遷移グラフを表示
- テーマ3（eo 包含）: 変更なし（構造的性質）
- テーマ4（ドライバー到達性）: resolve ベースに視点変更
  - 「P_target の resolve が N に届くか」の検証に変更
- テーマ5（新規）: 近傍構造の表示
  - 各パラダイムの近傍と Remaining 集合を出力
  - N(P_target) の上限と設定値を表示

**shift_direction.py**:
- シミュレーションの発動条件を新方式に変更
  - `tension > threshold` → `resolve >= N(P_target) AND tension strict <`
- 候補詳細の表示を resolve/attention に更新

**transition_drive.py**:
- `compute_main_path()` を新ロジックに合わせて更新（shift_direction.py から import）
- 駆動率の計算ロジック自体は P_pred 構造分析なので大きな変更なし

**shift_quality.py**:
- シフト発生記録を新方式に更新
- N(P_target) と resolve の記録を追加

### Phase 4: 検証

- `python3 app/poc/scripts/eval/check/shift_path.py` — 近傍構造表示 + 全テーマ
- `python3 app/poc/scripts/eval/check/shift_direction.py` — 動的シミュレーション
- `python3 app/poc/scripts/eval/metric/shift/shift_quality.py` — エラーなく実行
- `python3 app/poc/scripts/play_simulation.py` — メインパス遷移の確認
- `python3 app/poc/scripts/eval/metric/shift/transition_drive.py` — 既存出力と比較

### 変更しないファイル

| ファイル | 理由 |
|---------|------|
| convert_formalization.py | データ変換、エンジン非依存 |
| anomaly_emergence.py | 診断指標、シフトロジック非依存 |
| ps_paradigm.py | Conceivable カバレッジ、シフト非依存 |
| opening_reach.py | 質問オープン構造、シフト非依存 |
| bridging.py 等 structure/ | 質問構造分析、シフト非依存 |

## 残課題

- **N(P_target) の具体値**: 上限からの調整はパズル設計者の判断
- **データの修正**: S1/S2 の引っ掛け構造の不成立をデータ設計で対応
- **到達性検証**: 各パラダイムの質問で resolve が N に届くかのチェック（テーマ4 で対応）
